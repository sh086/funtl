# 零基础玩转微信小程序

​      微信小程序，简称小程序，英文名`Mini Program`，是一种不需要下载安装即可使用的应用，它实现了应用“"触手可及"的梦想，用户扫一扫或者搜一下即可打开应用。

- [官方微信小程序体验](https://github.com/wechat-miniprogram/miniprogram-demo)
- [微信小程序官方文档](https://developers.weixin.qq.com/miniprogram/dev/framework/)
- [微信小程序开发工具下载](https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html)




# 小程序简介

**1 为什么是微信小程序？**

```
- 微信有海量⽤⼾，⽽且粘性很⾼，在微信⾥开发产品更容易触达⽤⼾； 
- 推⼴app 或公众号的成本太⾼。 
- 开发适配成本低。 
- 容易⼩规模试错，然后快速迭代。 
- 跨平台。 
```



**2 小程序第三方框架**

```
- 腾讯wepx  类似vue
- 美团mpvue 语法类似vue
- 京东taro  类似react
- 滴滴chameleon
- uni-app 类似vue
```



# 快速开始

​        首先，使用一个**没有注册过其他小程序或者公众号的邮箱**完成[注册](https://mp.weixin.qq.com/wxopen/waregister?action=step1)，注册通过后即可[登录](https://mp.weixin.qq.com/)小程序管理页面，点击右侧的`开发` -> `开发设置`，在开发者ID中找到**AppID**。

​        接着，需要下载集成**开发、预览、调试、发布**于一身的[微信小程序开发工具](https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html)，下载完后后，输入**项目名称**、**目录**，AppID点击使用**测试号**或者输入自己的**AppID**，最后点击`新建`按钮，即可完成小程序项目的新建。



## 小程序结构目录

​        ⼩程序框架的⽬标是通过尽可能简单、⾼效的⽅式让开发者可以在微信中开发具有原⽣APP体验的服务。

**1 小程序文件结构**

​        ⼩程序框架提供了⾃⼰的视图层描述语⾔ WXML 和 WXSS ，以及 JavaScript ，并在视图层与逻 辑层间提供了数据传输和事件系统，让开发者能够专注于数据与逻辑。

|              |  传统Web   | 微信小程序 |
| :----------: | :--------: | :--------: |
|     结构     |    HTML    |    WXML    |
|样式  |    CSS     |    WXSS    |
| 逻辑 | Javascript | Javascript |
| 配置  |     -     |    JSON    |

**2 基本项目目录**

```
├── pages    页面文件夹
│   ├── index    首页    
│   │   ├── index.js      首页的逻辑文件
│   │   ├── index.json    首页的配置文件
│   │   ├── index.wxml    首页的标签文件
│   │   ├── index.wxss    首页的样式文件
│   ├── logs    日志页面    
│   │   ├── log.js      
│   │   ├── log.json    
│   │   ├── log.wxml    
│   │   ├── log.wxss    
├── utils    第三方的工具js（可删除）    
│   ├── utils.js 
├── app.js     入口文件
├── app.json   全局配置文件
├── app.wxss   全局样式文件
├── project.config.json   项目的配置文件
├── sitemap.json   微信索引配置文件
```



## 小程序配置文件

​        [小程序配置](https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html)包括最基本的两种配置文件，一种是全局的配置文件`app.json`，另一种是页面配置文件`page.json`。

> 注意：配置文件中不能出现注释



**1 全局配置文件 app.json**

​        ⼩程序的全局配置文件`app.json`包括了⼩程序的所有⻚⾯路径、界⾯表现、⽹络超时时间、底 

部 tab 等。

**1.1 pages 标签**

​        pages标签用于描述当前小程序的页面路径，小程序的首页路径就是pages字段中第一个路径。

```json
{
  "pages":[
    "pages/index/index",
    "pages/logs/logs"
  ]
}
```

> 说明：编辑pages页面路径，点击保存，微信开发者工具会自动帮助你新建组件目录



**1.2 window 标签**

​        window标签定义了小程序所有页面的`顶部`背景颜色、文字颜色等，如：

```json
{
  "window":{
    "navigationBarBackgroundColor": "#fff",
    "navigationBarTitleText": "Weixin",
    "navigationBarTextStyle":"black",
    "enablePullDownRefresh": true,
    "backgroundTextStyle":"dark",
    "backgroundColor": "#0094ff"
  }
}
```



（1）导航栏标签

```
navigationBarBackgroundColor: 导航栏背景颜色，只可使用十六进制，如：#fff
navigationBarTitleText ：导航栏标题
navigationBarTextStyle ：导航栏标题字体颜色,值只可为black或者white
```

（2） loading标签

```
enablePullDownRefresh：是否启用下拉刷新，值只可为true或false
onReachBottomDistance ：
backgroundTextStyle：下拉刷新时loading小圆圈的字体颜色，值只可为dark或者light
backgroundColor：下拉时loading的背景颜色，只可使用十六进制，如：#0094ff
```



**1.3 tabbar 标签**

​        tabbar标签定义小程序`导航栏`的相关属性，如：

```json
{
  "tabBar": {
    "list": [
      {
        "pagePath": "pages/index/index",
        "text": "首页",
        "iconPath": "icon/_home.png",
        "selectedIconPath": "icon/home.png"
      }
    ],
    "color": "#0094ff",
    "selectedColor": "#ff9400",
    "backgroundColor": "#ff5533",
    "position": "top"
  }
}

```

（1） list标签明细含义

```
pagePath : 图标对应的页面路径
text ： 图标名称
iconPath：未选中的图标路径
selectedIconPath：已选中的图标路径
```

> 注意：tabbar中list需至少包含 2 项



（2） tabbar 标签明细含义

```
color：未选中图标名称
selectedColor ： 选中图标名称
backgroundColor ： tabbar导航背景颜色
borderStyle ： tabbar边框颜色
position：设置tabbar显示的位置，默认显示在底部，若值为top则会显示在顶部
```



**2 页面配置文件page.json**

​        页面配置文件page.json主要用于表示页面相关配置，开发者可以独⽴定义每个⻚⾯的⼀些属性，如顶部颜⾊、是否允许下拉刷新等等。**⻚⾯的配置只能设置 app.json 中部分 window 配置项的内容**，**⻚⾯中配置项会覆盖 app.json的 window 中相同的配置项**。

（1）示例

```json
{
  "usingComponents": {},
  "navigationBarBackgroundColor": "#0094aa",
  "navigationBarTitleText": "我的首页",
  "disableScroll": false
}
```

（2）特殊的页面配置标签

```
disableScroll ：默认true，表示不能页面整体上下滚动，只有在页面配置中有效，无法在app.json中设置该项
pageOrientation：默认未开启，设置为"auto"表示开启页面横屏竖屏设置
```



**3 微信索引配置文件sitemap.json**

​        ⼩程序根⽬录下的 sitemap.json ⽂件⽤于配置⼩程序及其⻚⾯是否允许被微信索引。 



# 框架

   WXML（WeiXin Markup Language）是框架设计的⼀套标签语⾔，结合基础组件、事件系统，可以构 建出⻚⾯的结构。

说明：小程序不需要主动引入JSON文件、WXSS样式文件、JS文件等，小程序会自动引入同名文件的。



## Page绑定

### 数据绑定

**1 绑定页面数据**

（1）在.js中添加数据

```js
Page({
  data: {
    num : 12,
    message : "HelloWord",
    isHappy : true,
    person :{
      name : "小明",
      age : 12
    }
  },
})
```

（2）在页面中绑定数据

```xml
<view> 绑定数字类型：{{num}} </view>
<view> 绑定字符串类型 ：{{message}} </view>
<view> 绑定bool类型：{{isHappy}} </view>
<view> 绑定Object类型：姓名-{{person.name}} 年龄-{{person.age}} </view>
```



**2 绑定组件属性**

（1）在.js中添加数据

```js
Page({
  data: {
     id : 1,
     num : 12
  },
})
```

（2）在页面中绑定组件属性

```xml
<view id = "item-{{id}}" data-num = "{{num}}"> 自定义组件属性 </view>
```

（3）结果展示

```xml
<view id="item-1" data-num="12"> HelloWord </view>
```



**3 绑定bool类型充当属性**

```xml
<checkbox checked="{{false}}"> </checkbox>
<checkbox checked> </checkbox>
```

① 不要直接写 checked=false，因为这样的计算结果是⼀个字符串 

② checked默认为true，表示被选中



**特别注意**：花括号和引号之间如果有空格，将最终被解析成为字符串 ，错误示例如下：

```xml
<checkbox checked="   {{false}}"> </checkbox>
```



### 事件绑定

​        ⼩程序中绑定事件，通过**bind**关键字来实现。如 bindtap用于绑定button的事件、bindinput用于绑定input的事件、bindchange等，不同的组件⽀持不同的事件，具体看组件的说明即可。接下来编写一个自增的示例代码进行演示：

**（1）设计数据模型**

```js
Page({
    data: {
     value: 0
    }
})
```

**（2）编写WXML页面**

```xml
<view>
    <input type="text"  value="{{value}}" bindinput="handleInput"/>
    <button bindtap="handleTap" data-operation="{{1}}">+</button>
    <button bindtap="handleTap" data-operation="{{-1}}">-</button>
</view>
```

​        input组件通过bindinput绑定了handleInput事件，该事件可以将用户在输入框输入的值绑定到`value`中，点击加号按钮，将加号按钮设置的初始值1传入handleTap进行运算，点击减号同理。

**（3）事件绑定**

```js
Page({
    data: {
     value: 0
    },
    handleInput: function(e) {
      this.setData({
        value : parseInt(e.detail.value)
      })
    },
    handleTap: function(e) {
      const operation = e.currentTarget.dataset.operation;
      this.setData({
        value : this.data.value + operation
      })
    }
})
```



**（4）特别注意**

① 绑定事件时**不能带参数**、**不能带括号** ，传参需要使用`data-参数名`设置需要传入的自定义属性，然后使用`e.currentTarget.dataset.参数名`取用设置的自定义属性。

```xml
<!--错误写法-->
<input bindinput="handleInput(100)" />
<!--正确写法-->
<input bindinput="handleInput" data-item="100" />
```

② 绑定的事件中，可以通过`this.data.value`取用value值，但是**不能通过this.data.value设置value值**，设置value需要通过`this.setData({})`方法

```js
this.setData({
	value : 2
})
```



### 事件源e

​        绑定事件中的e是事件源，包含了事件的信息

```
 e.currentTarget.dataset 自定义属性值，Object类型
 e.detail.value 输入组件的值
 e.detail 传递过来的值
```



## 语句



### 运算表达式

​       表达式包含算术运算表达式、字符串拼接、逻辑运算表达式、三元运算表达式等类型，表达式可以在**花括号**中执行。

**1 三元运算**

```xml
<view hidden="{{flag ? true : false}}"> Hidden </view>
```



**2 算术运算**

（1）在.js中添加数据

```json
Page({
  data: {
    a: 1,
    b: 2,
    c: 3
 }
})
```

（2）在页面中绑定组件属性

```xml
<view> {{a + b}} + {{c}} + d </view>
```



**3 字符串运算**

（1）在.js中添加数据

```json
Page({
  data:{
    name: 'MINA'
 }
})
```

（2）在页面中绑定组件属性

```xml
<view>{{"hello" + name}}</view>
```



### 条件渲染

​        首先，在page中准备好相关对象，接下来我们会通过`wx:if`和`hidden`进行条件渲染的。

```js
Page({
  data: {
    condition: false
  },
})
```

#### wx:if

**（1）单分支条件渲染**

```xml
<view wx:if="{{condition}}">隐藏</view>
<view wx:if="{{!condition}}">显示</view>
```

**（2）多分支条件渲染**

```xml
<view wx:if="{{condition}}">路径1</view>
<view wx:elif="{{condition}}">路径2</view>
<view wx:else>路径3</view>
```

显示结果：

```
路径3
```



#### hidden

​        `hidden`和`wx:if`都可以使标签显示或者隐藏，区别是当**标签频繁的切换显示时**优先使用 `hidden`，**不常频繁切换时**，优先使用`wx:if`。

```xml
<view hidden="{{condition}}"> Hidden </view>
<view hidden> Hidden </view>
```

>  hidden默认为true，表示隐藏



**特别注意**：当通过添加样式的方式切换显示的时候，hidden属性不要和样式`display`一起使用，否则display的样式会将hidden覆盖掉的。

```xml
<view style="display: flex;" hidden="{{!condition}}"> hidden </view>
```

运行结果：

```shell
# display样式为显示，hidden为隐藏。但是display样式会覆盖掉hidden的样式，所以hidden会显示
hidden
```



### 列表渲染

​        首先，在page中准备好相关对象，接下来我们会通过`wx:for`对这个list进行列表渲染。

```json
Page({
  data: {
     numberList: [1,2],
     objectList : [
       {id: 100, name : '小明'},
       {id: 101, name : '小红'}
    ],
    object : {id: 103, name : '小蓝'},
  },
})
```



#### wx:for

​        `wx:for`指定需要循环的数组或者对象；`wx:for-item`指定数组当前元素的变量名 ，默认为 item；`wx:for-index`指定数组当前下标的变量名默认为 index。**只有一层循环的时候**，wx:for-item和wx:for-index可以不写，采用默认的名称，但是当出现 **数组的嵌套循环** 的时候，wx:for-item和wx:for-index必须要明确，而且尤其需要注意绑定的元素和下标的变量名不能重名。

​       wx:key ⽤来提⾼数组渲染的性能，绑定的值可以是String类型，但必须是循环数组中的对象的**唯一属性**；也可以是保留字 ` * this`，它的意思是 item本⾝ ，` * this` 代表的必须是 **唯⼀的字符串或数组**。 

**（1）遍历元素数组**

​        使用`wx:for`遍历numberList，未指明`wx:for-item`和`wx:for-index`，所以采用当前元素变量名默认为item，下标的变量名默认为 index。由于numberList是一个不重复的数组，所以`wx:key`采用的是` * this`。

```xml
<view wx:for="{{numberList}}" wx:key="*this">
  索引：{{index}}  值 {{item}} 
</view>
```

运行结果：

```
索引：0 值 1
索引：1 值 2
```



**（2）遍历对象数组**

​        使用`wx:for`遍历objectList，指明`wx:for-item`表示当前元素变量名为student，指明`wx:for-index`表示下标的变量名为number，指明`wx:key`为id。

```xml
<view wx:for="{{objectList}}" wx:for-item="student" wx:for-index="number" wx:key="id">
  索引：{{number}}  编号： {{student.id}} 姓名： {{student.name}}
</view>
```

运行结果：

```
索引：0  编号： 100 姓名： 小明
索引：1  编号： 101 姓名： 小红
```



**（3）遍历对象**

​        使用`wx:for`遍历object，建议将`wx:for-index`指定为key，`wx:for-item`指定为value。

```xml
<view wx:for="{{object}}" wx:for-item="value" wx:for-index="key">
  索引：{{key}}  值 {{value}} 
</view>
```

运行结果：

```
索引：id  值 103
索引：name  值 小蓝
```



#### block

​        block是**占位符标签**，在渲染⼀个包含多节点的结构块时， block标签最终不会被渲染成真正的dom元素 ，而`view`在列表渲染时会作为一个真正的DOM元素渲染的。

```xml
<view wx:for="{{numberList}}">
  <view>索引：{{index}}  值 {{item}} </view>
</view >
```

运行结果：

```xml
<page>
    <view>
        <view>索引：0  值 1 </view>
    </view>
    <view>
        <view>索引：1  值 2 </view>
    </view>
</page>
```

​        我们可以使用`block`标签替代`view`标签，会发现block标签最终不会被渲染成dom元素。

```xml
<block wx:for="{{numberList}}" wx:for-item="item" wx:for-index="index">
  <view>索引：{{index}}  值 {{item}} </view>
</block>
```

运行结果：

```xml
<page>
    <view>索引：0  值 1 </view>
    <view>索引：1  值 2 </view>
</page>
```



## WXSS样式

​        WXSS( WeiXin Style Sheets )是⼀套样式语⾔，⽤于描述 WXML 的组件样式。 与 CSS 相⽐，WXSS 扩展的特性有： 

- 响应式⻓度单位 rpx
- 样式导⼊ 

### 小程序样式

**1 尺寸单位**

​        rpx （responsive pixel）: 可以根据屏幕宽度进⾏⾃适应。规定屏幕宽为 `750rpx` 。如在iPhone6 上，屏幕宽度为 375px ，共有750个物理像素，则 ：

```
750rpx = 375px = 750  物理像素
1rpx = 0.5px = 1      物理像素
```

​        建议开发微信⼩程序时设计师可以⽤ iPhone6 作为视觉稿的标准，开发时需要把视觉稿中元素的单位由 `px` 改成 `rpx`，计算步骤如下： 

```
1. 确定设计稿宽度 pageWidth 
2. 计算⽐例 750rpx = pageWidth px ,因此 1px = 750rpx /pageWidth 
3. 最终公式：m px = 750rpx * m / pageWidth
```

**应用实例**：

​        存在一个设计稿宽度是414px，而且设计稿中存在一个宽度是100px、高200的蓝色区域，将px转为rpx的写法如下：

```css
view{
  width:calc(750rpx * 100 / 414);
  height: calc(750rpx * 200 / 414);
  background-color: aqua;
}
```

① css和wxss都支持calc属性，它可以帮助我们计算

② 750rpx的750 和 rpx中间 不能存在空格



**2 选择器**

|      选择器      |       样例        |                    样例描述                    |
| :--------------: | :---------------: | :--------------------------------------------: |
|      .class      |      .intro       |        选择所有拥有 class="intro"的组件        |
|       #id        |        #id        |         选择拥有 id="firstname"的组件          |
|     element      |       view        |               选择所有 view 组件               |
| element, element |   view,checkbox   | 选择所有⽂档的 view 组件和所有的 checkbox 组件 |
|   nth-child(n)   | view:nth-child(n) |               选择某个索引的标签               |
|     ::after      |    view::after    |            在 view 组件后边插⼊内容            |
|     ::before     |   view::before    |            在 view 组件前边插⼊内容            |

**特别注意**： ⼩程序 不⽀持`通配符 *` 因此以下代码⽆效：

```css
*{
    margin:0;
    padding:0;
    box-sizing:border-box; 
}
```



**3 样式导入**

​        wxss中可以使⽤ `@import` 语句导⼊外联样式表，但注意**只⽀持相对路径**。 

（1）编写 common.wxss样式文件

```css
/** common.wxss **/
.small-p {
  padding:5px; 
}
```

（2）在wxss中导入common.wxss文件

```css
@import "common.wxss";
.middle-p {
  padding:15px; 
}
```



### less样式

​        可以通过VScode编辑器来使用less转wxss的功能，需要需要在VScode中下载`easy Less`的插件，安装完成后，需要在VScode编辑器的设置中加入如下配置：

```json
"less.compile": {
	"outExt": ".wxss"
}
```

（1）编辑less样式文件

① 先新建common.less ，并定义less变量

```css
/**定义less变量**/
@color: yellow;
```

② 在VSCode中新增与wxss的同名文件less

```css
/**可以使⽤ @import 语句导⼊外联less样式表，但注意只⽀持相对路径*/
@import "common.less";
/**单行样式**/
text{
  color: @color;
}
/**嵌套样式**/
view{
  .vie1{
      text{
          color: @color;
      }
  }
}
```



（2） less文件编辑完成并保存后，VSCode即可根据less文件在wxss文件中生成对应wxssَ样式，生成的wxssَ样式如下：

```css
text{
  color: yellow;
}

view .vie1 text{
    color: yellow;
}
```



## 小程序生命周期

**1 应用生命周期**

| 属性           | 类型     | 说明                                                         |
| -------------- | -------- | ------------------------------------------------------------ |
| onLaunch       | function | 监听⼩程序初始化，应用第一次启动时触发                       |
| onShow         | function | 监听⼩程序启动或切前台                                       |
| onHide         | function | 监听⼩程序切后台                                             |
| onError        | function | 错误监听函数，在应用发生代码报错时，收集用户的错误信息，通过异步请求，将错误的信息发送到后台 |
| onPageNotFound | function | 应用第一次启动时，若找不到第一个入口页面，才会触发           |

**2 页面声明周期**

| 属性              | 类型     | 说明                                                         |
| ----------------- | -------- | ------------------------------------------------------------ |
| data              | Object   | ⻚⾯的初始数据                                               |
| onLoad            | function | 监听⻚⾯加载，用于发送异步请求初始化页面                     |
| onShow            | function | 监听⻚⾯显⽰                                                 |
| onReady           | function | 监听⻚⾯初次渲染完成                                         |
| onHide            | function | 监听⻚⾯隐藏                                                 |
| onUnload          | function | 监听⻚⾯卸载                                                 |
| onPullDownRefresh | function | 监听⽤⼾下拉动作                                             |
| onReachBottom     | function | ⻚⾯上拉触底事件的处理函数，用于上拉自动加载下一页           |
| onShareAppMessage | function | ⽤⼾点击右上⻆转发                                           |
| onPageScroll      | function | ⻚⾯滚动触发事件的处理函数                                   |
| onResize          | function | ⻚⾯尺⼨改变时触发，详⻅ 响应显⽰区域变化 。如在横屏竖屏切换时触发 |
| onTabItemTap      | function | 当前页面是tabbar页面，在点击自己的tabItem时触发              |



**参考文献**：

![页面生命周期图解.jpg](https://github.com/camelliahub/filecloud/blob/master/class/images/%E9%A1%B5%E9%9D%A2%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE%E8%A7%A3.jpg?raw=true)



# 组件

## 视图容器

### view

​       `view`相当于HTML中的`div`标签，是一个块级元素，会换行展示。

```xml
<view> This is View </view>
```



### swiper

​        `swiper`是微信内置的外层轮播图组件，`swiper-item`是轮播图里面的轮播项。

**（1）swiper常用属性**

|         属性名         |  类型   |      默认值       |         说明         |
| :--------------------: | :-----: | :---------------: | :------------------: |
|     indicator-dots     | Boolean |       false       |  是否显⽰⾯板指⽰点  |
|    indicator-color     |  Color  | rgba(0, 0, 0, .3) |      指⽰点颜⾊      |
| indicator-active-color |  Color  |     `#000000`     | 当前选中的指⽰点颜⾊ |
|        autoplay        | Boolean |       false       |     是否⾃动切换     |
|        interval        | Number  |       5000        |   ⾃动切换时间间隔   |
|        circular        | Boolean |       false       |     是否循环轮播     |

**（2）图片适应swiper的宽高**

​        `swiper`组件存在默认样式，**默认宽度是100%，默认高度是150px**；`swiper-item`组件**默认宽度和高度都是100%**。当swiper组件的默认高度无法实现内容撑开的时候，需要依据原图的宽度和高度，自定义swiper的高度和宽度。

**计算公式为：**

```
∵ swiper宽度 / swiper高度 = 原图宽度 / 原图高度
∴ swiper高度 = swiper宽度 * 原图高度 / 原图宽度
```

说明：swiper高度是一个固定值，可以写成 750rpx ,也可以写成 100vw。



**（3）代码示例**

​          采用一个原图大小：1125 * 352像素的图片，首先image样式写入 **width: 100%;**表明采用image默认样式，即宽高为`320px * 240px`；然后设定**mode="widthFix"** ，表名将原图宽度缩放到320px，高根据比例进行缩放。计算的知缩放后图片为`320px * 100px`。

​        而swiper组件默认宽度是100%，默认高度是150px，即`320px * 150px`，此时图片高度不能将swiper组件完全撑开，导致面板指⽰点的显示位置不准确（面板指⽰点是跟随swiper组件底部显示的），需要依据原图的高度，自定义swiper的高度，计算公式是：calc(100vw * 352 /  1125)。



① wxss的样式

```css
swiper {
  width: 100%; 
  height: calc(100vw * 352 /  1125); 
}
image {
  width: 100%;
}
```

② wxml轮播图

```html
<swiper autoplay circular interval="1000" 
        indicator-dots indicator-color="#0094ff" 
        indicator-active-color="#ff0094">
    <swiper-item> 
      <image mode="widthFix" 
             src="//gw.alicdn.com/imgextra/i1/44/O1CN013zKZP11CCByG5bAeF_!!44-0-lubanu.jpg" /> 
    </swiper-item>
    <swiper-item> 
      <image mode="widthFix" 
             src="//aecpm.alicdn.com/simba/img/TB1CWf9KpXXXXbuXpXXSutbFXXX.jpg_q50.jpg" /> 
    </swiper-item>
    <swiper-item> 
      <image mode="widthFix" 
             src="//gw.alicdn.com/imgextra/i2/37/O1CN01syHZxs1C8zCFJj97b_!!37-0-lubanu.jpg" /> 
    </swiper-item>
</swiper>
```



## 基础内容

### text

**（1）text常用属性**

|   属性名   |  类型   | 默认值 |           说明           |
| :--------: | :-----: | :----: | :----------------------: |
| selectable | Boolean | false  | 表示是否可以长按文字复制 |
|   decode   | Boolean | false  |         是否解码         |

①   decode为true时，文本会被解码，若decode为false，则原样输出。

```xml
<text decode="{{true}}"> 算式：&nbsp; 1 &lt; 2 </text>
<text decode="{{false}}"> &nbsp;</text>
```

运行结果：

```js
算式： 1 < 2&nbsp;
```

② selectable标签只有text标签有该属性，且只能在真机调试中测试



**（2）注意要点**

① 文本标签`text`相当于HTML中的`span`标签，是一个行内元素，不会换行展示。

```xml
<text> This is Test1 </text>
<text> This is Test2 </text>
```



② text标签只能嵌套text标签

```xml
<text>
    <text> This is Test1 </text>
    <input> This is Test2 </input>
</text>
```

运行结果：

```
This is Test1
```



### icon

​        icon是图标标签，使用type属性表示不同的icon图标，type有效值：success, success_no_circle, info, warn, waiting, cancel, download, search, clear。icon常用属性如下：

| 属性  | 类型          | 默认值 | 必填 | 说明                     |
| ----- | ------------- | ------ | ---- | ------------------------ |
| type  | string        |        | 是   | icon的类型               |
| size  | number/string | 23     | 否   | icon的⼤⼩               |
| color | string        |        | 否   | icon的颜⾊，同css的color |



（1）Page数据

```js
Page({
   data: {
     iconSize: [20, 30, 40, 50, 60, 70],
     iconType: [
         'success', 'success_no_circle', 'info', 'warn', 'waiting', 
         'cancel', 'download','search', 'clear'
    ],
     iconColor: [
       'red', 'orange', 'yellow', 'green', 'rgb(0,255,255)', 'blue', 'purple'
    ],
  }
 })
```



（2）WXML标签

```html
<view class="group">
  <block wx:for="{{iconSize}}">
    <icon type="success" size="{{item}}"/>
  </block>
</view> 
<view class="group">
  <block wx:for="{{iconType}}">
    <icon type="{{item}}" size="40"/>
  </block>
</view> 
<view class="group">
  <block wx:for="{{iconColor}}">
    <icon type="success" size="40" color="{{item}}"/>
  </block>
</view>
```



### rich-text

​        `rich-text`是富文本标签，使用nodes属性可以将字符串解析成 对应标签，类似 vue中 `v-html`功能。 nodes 属性⽀持 字符串 和 标签节点数组。特别注意：

- rich-text 组件内屏蔽所有节点的事件
- img 标签仅⽀持⽹络图⽚



**1 解析html字符串 [最长使用]**

```xml
<rich-text 
  nodes='<img src="https://tva2.sinaimg.cn/large/007DFXDhgy1g51jlzfb4lj305k02s0sp.jpg"/>' >
</rich-text>
```



**2 使用标签节点数组**

（1）标签节点数组属性

|   属性   |    说明    |  类型  | 必填 |                   备注                   |
| :------: | :--------: | :----: | :--: | :--------------------------------------: |
|   name   |   标签名   | string |  是  |        ⽀持部分受信任的 HTML 节点        |
|  attrs   |    属性    | object |  否  | ⽀持部分受信任的属性，遵循 Pascal 命名法 |
| children | ⼦节点列表 | array  |  否  |            结构和 nodes ⼀致             |

**⽂本节点：type = text**

| 属性 | 说明 |  类型  | 必填 |     备注     |
| :--: | :--: | :----: | :--: | :----------: |
| text | ⽂本 | string |  是  | ⽀持entities |

**特别注意：**

- attrs 属性不⽀持 id ，⽀持 class 
- name 属性⼤⼩写不敏感
- 如果使⽤了不受信任的 HTML 节点，该节点及其所有⼦节点将会被移除。




（2）示例代码

① 在js中新建node节点

```js
// pages/demo12/demo12.js
Page({
  data: {
    html:[
      {
        // 1 div标签 name属性来指定
        name:"div",
        // 2 标签上有哪些属性
        attrs:{
          // 标签上的属性 class  style
          class:"my_div",
          style:"color:red;"
        },
        // 3 子节点 children 要接收的数据类型和 nodes第二种渲染方式的数据类型一致 
        children:[
          {
            type:"text",
            text:"Hello&nbsp;World!"
          }
        ]
      }
    ]
  }
})
```

② wxml中展示node节点

```xml
<rich-text nodes="{{nodes}}"></rich-text>
```

显示结果：

```
Hello World!
```



## 表单组件

### button

​        button是按钮标签，常用属性如下：

|   属性    |  类型   | 默认值  |             说明             |
| :-------: | :-----: | :-----: | :--------------------------: |
|   size    | string  | default |          按钮的大小          |
|   type    | string  | default |        按钮的样式类型        |
|   plain   | boolean |  false  |   按钮是否镂空，背景色透明   |
| disabled  | boolean |  false  |           是否禁用           |
|  loading  | boolean |  false  |  名称前是否带 loading 图标   |
| form-type | string  |         | 触发组件的 submit/reset 事件 |
| open-type | string  |         |         微信开放能⼒         |

**1 外观属性**

（1）size合法值

|   值    |   说明   |
| :-----: | :------: |
| default | 默认⼤⼩ |
|  mini   |  ⼩尺⼨  |



（2）type合法值

|   值    | 说明 |
| :-----: | :--: |
| primary | 绿⾊ |
| default | ⽩⾊ |
|  warn   | 红⾊ |



（3）form-type合法值

|   值   |   说明   |
| :----: | :------: |
| submit | 提交表单 |
| reset  | 重置表单 |



**2 open-type微信开发能力**

​        如果需要使用微信开发者功能，则首先需要将⼩程序 的 appid 由测试号改为 ⾃⼰的 appid 

|       值       | 说明                                                         |
| :------------: | :----------------------------------------------------------- |
|    contact     | 打开客服会话。该功能需要登录微信⼩程序官⽹，在 `客服 - 微信`中配置客服微信，如果⽤⼾在会话中点击消息卡⽚后返回⼩程序，可以从 bindcontact 回调中获得具体信息 |
|     share      | 转发当前小程序到微信朋友中，但不能把小程序分享到朋友圈       |
| getPhoneNumber | 若是企业小程序账户，则可以获取⽤⼾⼿机号，可以从bindgetphonenumber回调中获取到⽤⼾信息，但是获取的信息是加密的 |
|  getUserInfo   | 获取⽤⼾信息。可以从bindgetuserinfo回调中获取到⽤⼾信息，信息未进行加密处理 |
|   launchApp    | 在小程序中直接打开APP，可以通过app-parameter属性设定向APP传的参数 |
|  openSetting   | 打开小程序内置的授权页面                                     |
|    feedback    | 打开“意⻅反馈”⻚⾯。⽤⼾可提交反馈内容并上传⽇志，开发者可以登 录⼩程序管理后台后进⼊左侧菜单“客服反馈”⻚⾯获取到反馈内容 |



### checkbox

​        radio是复选框标签，**checkbox标签必须要和 父元素 checkbox-group来使用**，value属性表示选中的复选框的值。示例代码如下：

① Page数据

```js
Page({
   data: {
      checkList:[],
      list:[
        {"id":1, value: "草莓"},
        {"id":2, value: "西瓜"},
      ]
  },
  hangdleChange(e){
    const checkList = e.detail.value;
    this.setData({
      checkList
    })
  }
 })
```



② wxml页面

```html
<checkbox-group bindchange = 'hangdleChange'>
  <checkbox value="{{item.value}}" wx:for="{{list}}" wx:key="id">
    {{item.value}}
  </checkbox>
</checkbox-group>

<view>您选中的是：{{checkList}}</view>
```



### radio

​        radio是单选框标签，**radio标签必须要和 父元素 radio-group来使用**，value属性表示选中的单选框的值。示例代码如下：

① Page数据

```js
Page({
   data: {
      gender:"",
  },
  hangdleChange(e){
    const gender = e.detail.value;
    this.setData({
      gender
    })
  }
 })
```



② wxml页面

```html
<radio-group bindchange = 'hangdleChange'>
  <radio value="male">男</radio>
  <radio value="female">女</radio>
</radio-group>

<view>您选中的是：{{gender}}</view>
```



## 导航

### navigator

​        navigator是导航组件，类似于超链接标签，navigator常用属性如下：

|  属性名   |  类型  |  默认值  |                             说明                             |
| :-------: | :----: | :------: | :----------------------------------------------------------: |
|  target   | String |   self   | 在哪个⽬标上发⽣跳转，默认当前⼩程序，可选值 self或者miniProgram |
|    url    | String |          |                    当前⼩程序内的跳转链接                    |
| open-type | String | navigate |                           跳转⽅式                           |

**（1）url属性**

​        url属性表示要跳转的页面路径，可以是 **绝对路径** 也可以是 **相对路径**。

```html
<navigator url='/pages/mine/mine'>跳转页面</navigator>
```

① 默认情况下open-type是navigate，所以跳转时保留当前⻚⾯，跳转到应⽤内的某个⻚⾯，但是不能跳到tabbar ⻚⾯。

② 默认情况下target值是self，表示只能在当前⼩程序内的跳转链接。

③ 跳转的路径指向的是wxml文件，但是无需加`.wxml`后缀名



**（2）target跳转目标类型**

|     值      | 说明                               |
| :---------: | ---------------------------------- |
|    self     | 默认值，只能跳转到当前小程序的页面 |
| miniProgram | 可以跳转到其他小程序页面中         |

示例代码：

```html
<navigator target="self" url='/pages/mine/mine'>跳转页面</navigator>
```



**（3）open-type跳转⽅式**

|      值      | 说明                                                         |
| :----------: | ------------------------------------------------------------ |
|   navigate   | 默认值，保留当前⻚⾯，跳转到应⽤内的某个⻚⾯，但是不能跳到tabbar ⻚⾯ |
|   redirect   | 关闭当前⻚⾯，跳转到应⽤内的某个⻚⾯，但是不允许跳转到tabbar ⻚⾯。 |
|  switchTab   | 跳转到 tabBar ⻚⾯，并关闭其他所有⾮ tabBar ⻚⾯             |
|   reLaunch   | 关闭所有⻚⾯，打开到应⽤内的某个⻚⾯                         |
| navigateBack | 关闭当前⻚⾯，返回上⼀⻚⾯或多级⻚⾯。可通过 getCurrentPages() 获取当前的⻚⾯栈，决定需要返回⼏层 |
|     exit     | 退出⼩程序，target=miniProgram时⽣效                         |



## 媒体组件

### image

​        `image`是图片标签，常用属性如下：

|  属性名   |  类型   |   默认值    |         说明         |
| :-------: | :-----: | :---------: | :------------------: |
|    src    | String  |             |     图⽚资源地址     |
|   mode    | String  | scaleToFill | 图⽚裁剪、缩放的模式 |
| lazy-load | Boolean |    false    |      图⽚懒加载      |

**（1）src图⽚资源地址**

​       `src`属性值可以是**文件流**也可以是**文件地址**，特别注意：由于微信小程序要求程序打包上线的大小不能超过2M，所以**建议将静态资源都放到线上**。

```html
 <image src="https://tva2.sinaimg.cn/large/007DFXDhgy1g51jlzfb4lj305k02s0sp.jpg" />
```

**（2）图片缩放与裁剪**

​        image组件中`mode`决定**图片内容**如何和**图片标签宽高**做适配的。图片的**默认宽度是320px、高度是240px**。若image组件的宽高未设置，则image组件宽高默认是图片的宽高。

​        mode 有 13 种模式，其中 4 种是缩放模式，9种是裁剪模式。**缩放模式**是根据约定的mode缩放图片宽高，常用的有scaleToFill、aspectFit、widthFix；**裁剪模式**是图片宽高不变，在image组件中按照特点的方式显示图片。

| 模式 |     值     | 说明                                                 |
| :--: | :--------: | :--------------------------------------------------- |
| 缩放 | scaleToFill  | 默认值，表示不保持纵横比缩放图片，使图⽚的宽⾼完全拉伸⾄填满image 元素       |
| 缩放 | aspectFit  | 保持纵横⽐缩放图⽚，使图⽚的⻓边能完全显⽰出来，多用于页面轮播图 |
| 缩放 | aspectFill | 保持纵横⽐缩放图⽚，只保证图⽚的短边能完全显⽰出来，并会做居中处理 |
| 缩放 |  widthFix  | 宽度不变，⾼度⾃动变化（不受image组件高度的限制），保持原图宽⾼⽐不变 |
| 裁剪 |   bottom   | 不缩放图⽚，只显⽰图⽚的底部区域                      |

**（3）懒加载**

​       微信小程序中图片直接就支持懒加载，当图片出现在**视口上下三屏高度之内**的时候，`lazy-load`便会开始加载图片。

```html
 <image lazy-load src="https://tva2.sinaimg.cn/large/007DFXDhgy1g51jlzfb4lj305k02s0sp.jpg" />
```



## 自定义组件

​        ⼩程序允许我们使⽤⾃定义组件的⽅式来构建⻚⾯， 一个自定义组件由 `json`、`wxml`、`wxss`、`js` 四个文件组成。



### 快速创建组件

**1 创建自定义组件**

​       首先，在微信开发者⼯具中通过`新建Component的功能`，快速创建组件的四个⽂件结构。

```
| -- components
| ------ myHeader
| ---------- myHeader.wxml
| ---------- myHeader.json
| ---------- myHeader.wxss
| ---------- myHeader.js
```

​        接着，需要在组件的 json ⽂件中进⾏**⾃定义组件声明**，需要在组件的js文件中使⽤ `Component({})` 来**注册组件**。

```json
{
  "component": true
}
```

​        最后，要在组件的 wxml ⽂件中编写组件模板。

```html
<view class="inner">
	Hello Word!
</view>
```

 

**2 引用自定义组件**

​        首先，要在⻚⾯的 json ⽂件中进⾏**引⽤声明**，需要提供对应的**组件名**和**组件路径**。

```json
{
  "usingComponents": {
    "my-header": "../components/myHeader/myHeader"
  }
}
```

​        接着，就可以在wxml页面中引用这个组件了。

```html
 <my-header></my-header>
```

显示结果：

```
Hello Word!
```



### Component属性

​        在组件的 js ⽂件中，需要使⽤ Component() 来**注册组件**，并提供组件的属性定义、内部数据和 ⾃定义⽅法等。

| 定义段     | 类型       | 描述                                                  |
| ---------- | ---------- | ----------------------------------------------------- |
| properties | Object Map | 组件的对外属性，是属性名到属性设置的映射表            |
| data       | Object     | 组件的内部数据，和 properties ⼀同⽤于组件的模板渲染  |
| observers  | Object     | 组件数据字段监听器，⽤于监听properties 和 data 的变化 |
| methods    | Object     | 组件的⽅法，包括事件响应函数和任意的⾃定义⽅法        |

**Component属性应用实例：**

​        编写一个包含首页、原创、分类、关于的Tabs标签示例。

（1）组件wxml代码

```html
<view class="tabs_title">
	<view
	wx:for="{{tabs}}"
	wx:key="id"
	class="title_item {{item.isActive ? 'active' : ''}}"
	bindtap="hanldeItemTap"
	data-index="{{index}}">
		{{item.name}}
	</view>
</view>
```



（2）组件wxss文件

```css
.tabs_title{
  display: flex;
  padding: 10rpx 0;
}
.title_item{
  flex : 1;
  display: flex;
  justify-content: center;
  align-items: center;
}
.active{
  color: red;
  border-bottom: 5px solid currentColor;
}
```

> 注意：在组件wxss中不应使用ID选择器、属性选择器和标签名选择器



（3）组件js文件

​        组件.js 文件中 存放事件回调函数的时候 必须要存在在 methods中。

```js
Component({
  /**
   * 组件的初始数据
   */
  data: {
    tabs : [
      {
        id:0,
        name: "首页",
        isActive:true
      },
        {
          id:1,
          name: "原创",
          isActive:false
        },
        {
          id:2,
          name: "分类",
          isActive:false
        },
        {
          id:3,
          name: "关于",
          isActive:false
        }
      ]
  },

  /**
   * 组件的方法列表
   */
  methods: {
    hanldeItemTap (e) {
      // 获取当前索引
      const {index}=e.currentTarget.dataset;
      //获取data中的数组
      let {tabs} = this.data;
      tabs.forEach((v,i) => i === index ? 
      			v.isActive = true : v.isActive = false)
      this.setData({
        tabs
      })
    }
  }
})
```


**特别的：**

​        **解构**  对 **复杂类型**进行结构的时候 **复制了一份变量的引用**而已，最严谨的做法 **重新拷贝**一份 数组，再对这个数组的备份进行处理。

```js
let tabs=JSON.parse(JSON.stringify(this.data.tabs));
```



### 自定义组件传参

​        自定义组件传参有**⽗组件通过属性的⽅式给⼦组件传递参数** 和  **⼦组件通过事件的⽅式向⽗组件传递参数** 两种方式。

**1 ⽗组件通过属性的⽅式给⼦组件传递参数**

​       需求：将父页面的Tabs数据传入到子页面中进行显示

（1）在子组件JS中新增properties节点，并定义tabs属性

​        properties里面存放的是要从父组件中接收的属性定义，包括要接收的名称、数据类型和默认值，子组件可以当做data中的数据直接使用。

```js
Component({
  /**
   * 父组件中接收的属性定义
   */
  properties: {
    tabs : {
      type: Array,
      value : []
    }
  },
})
```

（2）在父组件JS中新增tabs数据

```js
Page({
  data: {
    tabs : [
      {
        id:0,
        name: "首页",
        isActive:true
      },
        {
          id:1,
          name: "原创",
          isActive:false
        },
        {
          id:2,
          name: "分类",
          isActive:false
        },
        {
          id:3,
          name: "关于",
          isActive:false
        }
      ]
  }
})
```

（3）在父组件的页面中将父组件的tabs数据传送到子组件中

```html
<tabs tabs="{{tabs}}"></tabs>
```

**存在问题**：

​        在点击导航栏不同标签时触发`hanldeItemTap`事件，该事件通过`this.data`获取`properties`中的tabs进行修改，但是修改完成后只能通过`setData`方法将修改完成的数据tabs拷贝到data中，而无法修改父组件中的tabs数据，使`Appdata`中tabs属性的数据无法更新。



**2 ⼦组件通过事件的⽅式向⽗组件传递参数** 

​        **子组件是不能直接修改父组件的属性的**，需要在子组件点击 事件触发的时候，**触发父组件中的自定义事件 同时传递数据给  父组件**  。

```
this.triggerEvent("父组件自定义事件的名称",要传递的参数)
```

（1）在父组件中新增自定义事件

```js
Page({
  handleItemChange(e){
    //获取子组件中传递过来的数据
    const {index} = e.detail;
    let {tabs} = this.data;
    tabs.forEach((v,i) => i === index ? 
          v.isActive = true : v.isActive = false)
    this.setData({
      tabs
    })
  }
})
```



（2）在父组件中绑定自定义事件`itemChange`到`handleItemChange`方法

```html
<tabs tabs="{{tabs}}" binditemChange = "handleItemChange"></tabs>
```



（3) 子组件绑定父组件的自定义事件`itemChange`，并将参数传递到父组件中

```js
Component({
  methods: {
    hanldeItemTap (e) {
      // 获取当前索引
      const {index}=e.currentTarget.dataset;
      this.triggerEvent("itemChange",{index})
    }
  }
})
```



### Slot占位符

​        slot标签其实就是一个占位符，在父组件调用子组件时，会将父组件中的标签传给子组件，来替换子组件中slot插槽的位置进行显示。

（1）tabs中新增slot插槽

```html
<view>
	<slot></slot>
</view>
```



（2）在父组件中加入block标签

```html
<tabs tabs="{{tabs}}" binditemChange = "handleItemChange">
  <block wx:if="{{tabs[0].isActive}}"> 首页页面 </block>
  <block wx:elif="{{tabs[1].isActive}}"> 原创页面 </block>
  <block wx:elif="{{tabs[2].isActive}}"> 分类页面 </block>
  <block wx:else>关于页面</block>
</tabs>
```



# 服务端

## 路径请求

#### navigateTo

​       navigateTo不能跳转到tabbar页面，和导航组件类似















































